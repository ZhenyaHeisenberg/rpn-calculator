## rpn-calculator

rpn-calculator это простой и эффективный калькулятор, работающий на основе алгоритма обратной польской записи (RPN), реализованный на Python.

Обратная польская запись (reverse Polish notation) — это математическая нотация, в которой операторы следуют за своими операндами Например, выражение `(3 + 4) * 5` в RPN записывается как `3 4 + 5 *`. Это исключает необходимость использования скобок и определяет порядок операций однозначно, однако в rpn-calculator вы можете использовать скобки для собсвенного удобства, если колличество символов "(" и ")" будет равным, калькулятор проигнорирует их, иначе - выдаст ошибку.

## Особенности

*   Поддержка базовых арифметических операций: `+`, `-`, `*`, `/`
*   Поддержка дополнительных операций: `^`, `//`, `%`
*   Обработка чисел с плавающей точкой (десятичная дробь)
*   Есть возможность запустить тесты





## Использование

После запуска вы увидите приглашение `Введите выражение:`. Вводите числа и операторы, разделяя их пробелами. Если выражение записано верно, вы увидете строку `Ответ:`, за которой будет следовать значение вашего выражения, если же выражение записано неверно, программа выдаст ошибку с пояснением.



## Правила для входных данных

*   **Числа**: Поддерживаются как целые числа, так и числа с плавающей точкой (например, `5`, `-3.14`). Целая и дробная части могут разделяться как точкой, так и запятой.
*   **Бинарные операторы**: Поддерживаются следующие бинарные операторы: `+`, `-`, `*`, `/`, `//`, `%`, `^`; где // - целочисленное деление, т.е. отбрасываение остатка (7 // 3 = 2, 15 // 3 = 5); % - вычисление остатка от деления (7 % 3 = 1, 15 % 3 = 0); ^ - возведение в степень.
    Вычисление корня происходит по следующему принципу: чтобы извлечь корень второй степени, достаточно возвести число в степень 1/2 = 0.5 (например, √5 = 5 0.5 ^), если же необходимо вычислить корень n-ной степени, возводить необходимо в степень 1/n (по правилам из математики n√a = a^(1/n) )  в RPN это будет выглядеть так:
    a 1 n / ^ -> число 1 делится на n, после чего число а возводится в степень 1/n
*   **Унарные операторы**
    Унарный минус может записываться двумя способами: непосредственно перед числом без пробела (непример, -5 6 + сложит числа -5 и 6, выдаст ответ 1), с помощью специального символа `~` по правилу остальных (бинарных) операторов (например, -(4 * 2) / 4 в RPN будет записываться как 4 2 * ~ 4 /), при необходимости применить унарный минус на выражение в скобках, стоит ставить его в виде `~` после скобки или в конце подскобочного выражения. Например, `-(5 4 +)` стоит записать в виде `(5 4 +)~` или `(5 4 + ~)`.
    Унарный плюс отсутсвует за ненадобностью, так как не влияет на результат.
*   **Разделитель**: Элементы в строке ввода должны разделяться одним или большим колличеством пробелов.
*   **Стек**: Для выполнения операций в стеке должно находиться достаточное количество операндов.
    *   Для бинарных операций (`+`, `-`, `*`, `/`, `^`, `//`, `%`) требуется не менее двух чисел слева от оператора.
    *   Для унарных операций (`~`) требуется не менее одного числа.
    В противном случае rpn-calculator выведет строку "Ошибка ввода операторов и операндов"
*   **Скобки**: Как уже было сказано, скобки не играют роли в обратной польской записи, однако в rpn-calculator их можно использовать для явности ввода (для собственного удобства). При этом, если в строке будут закрываться неоткрытые или открываться незакрытые скобки, это вызовет ошибку, а выражения внутри скобок должны быть осмысленные и полные.  Например, `(5 6) - ) (` -> `Ошибка: есть неоткрытые скобки`, `(( 4 6 - )` -> `Ошибка: есть незакрытые скобки`, `((5 6) - 3 *)` -> `Ошибка ввода операторов и операндов`, `((5 6 - ) 3 *)` -> `Ответ: -3.0`.



## Принятые решения и особенности реализации
Архитектура: Калькулятор разделен на логические модули (parser, check_brackets solve) для улучшения читаемости и тестируемости кода. parser преобразует строку ввода в стек, check_brackets проверяет правильность введенных скобок, а solve преобразует стек в ответ.

Обработка ошибок: Реализована детальная обработка ошибок (например, деление на ноль, недостаточное количество операндов в стеке, прменение // и % для нецелых чисел, неверное использование скобок), с понятными сообщениями для пользователя.

Точность вычислений: Для всех вычислений используется тип float. Следует учитывать возможные погрешности вычислений с плавающей точкой.

*   **Как это работает**: Строка преобразуется в список (1), после чего выбирается крайний левый опретор: унарный (2) или бинарный (3). Если оператор унарный т.е. ~ , то операнд, на который он применяется, умножается на -1 после чего оператор удаляется из списка. Если оператор бинарный, то на 2 операнда, стоящих слева от него, применяется данный оператор, после чего в значение первого операнда перезаписывается результат, а второй операнд и сам оператор удаляются из списка.
    *   Если слева от оператора недостаточно операндов (менее 2 для бинарных и 0 для унарных), то это свидетельствует об ошибке, и калькулятор выводит строку "Ошибка ввода операторов и операндов"
    *   При том слева от применяемого оператора всегда стоят только операнды (или он является первым в списке), так как выбирается крайний левый оператор. Это избавляет от необходимости проверять, не применяется ли оператор на другой оператор, а не на операнд, это упрощает работу кода и повышает читаемость.
    *   Также до начала вычислений строка проходит следующую проверку на корректность: 
    Известно, что для корректной работы калькурятора колличество бинарных операторов должно быть на 1 меньше, чем колличтесво операндов (например, 1 2 3 + выдал бы ошибку, так как в стеке останется 2 операнда без оператора). Обозначим колличество бинарных операторов как bin, колличество унарных как un, колличество чисел как num, а общее колличество символов как len
    Тогда len = num + bin + un, но определить колличество num в значительной степени сложнее, чем колличество bin и un, так как все операнды мы знаем заранее, а num может принимать разные значения. Тогда:
    len = num + bin + un
    {num = len - bin - un
    {num = bin + 1
    => len - bin - un = bin + 1 => len = 2*bin + un + 1
    Таким образом проверка len = 2*bin + un + 1 дает гарантию корректности выражения в этом плане, и при этом не усложняет работу кода.